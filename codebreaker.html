<html>
  <head>
    <meta charset="utf-8">
    <title>CodeBreaker</title>
    <style type="text/css">
      body {
        background-color: #2339de;
      }
      canvas {
        display: block;
        border: 0px solid black;
        margin: 0 auto;
      }
	  table {
		margin: 0 auto;
		border: 0px solid black;
	  }
      td {
        background-color: #2339de;
        border: 2.5px solid black;
      }
	  td.wood {
		background-image: url("Melamine-wood-001.png");
	  }
    </style>
  </head>

  <body>
    <center><img src="CodeBreaker.png"></center>
	<table>
	<tr>
		<td class="wood" width=30% style="padding:5px">
			<p><b>Goal:</b> Your mission in Codebreaker is to guess a secret four-color code created by the game. You have eight chances to guess the correct code. Every time you Test a row, the game will give you feedback based on your answer.</p>
			<p><b>How To Play</b></p>
			<p>1) Select a color from the six colors in the bottom center frame. The "Active Color" square in the bottom right of the game board shows your currently selected color.</p>
			<p>2) Click on the white boxes within the black rectangle on the gameboard to change their color and build your guess at the hidden code.</p>
			<p>3) When you have completed the row, click on "Test Row" to test your guess against the hidden code. You may only submit a guess once all the white squares in the black rectangle have been colored in.</p>
			<p>4) If your guesses are correct, you win. If you are incorrect, the game will display feedback white and black colored squares to the right of the active row of the gameboard. The guide to interpreting the feedback is on the right frame.</p>
			<p>5) If you run out of guesses (have filled up all the rows without guessing the correct code) the game is over. The correct answer will be displayed on the white rectangle in the upper left of the game board.
			<p>5) To erase your current row, click "Reset Row"</p>
			<p>6) To start over with a clean board and a new random hidden code, click "New Game"</p>
		</td>
		<td class="wood" width=40%>
			<canvas id="gameboard" width="400" height="700"></canvas>
		</td>
		<td class="wood" width=30%>
			<p>Feedback Guide:<b></b></p>
			<p></p>
		</td>
	</tr>
	<tr>
		<td class="wood" width=30%>
			<p></p>
		</td>
		<td class="wood">
			<canvas id="selector" width="370" height="70"></canvas>
		</td>
		<td class="wood" width=30%>
			RIGHT FRAME
		</td>
	</table>
	<div align="center">
		<button onclick="newGame()">New Game</button>
		<button onclick="resetRow()">Reset Row</button>
		<button onclick="testRow()">Test Row</button>
    </div>
	<p id="output"></p>
	<p>Sources</p>
	<p>Wood panelling: <a href="https://www.pixeden.com/graphic-web-backgrounds/wood-pattern-background" target="_blank">www.pixeden.com</a>

    <script>
		document.getElementById('output').innerHTML = 0;
		
		// create GameBoard context and mouse position tracker
		var game = document.getElementById('gameboard');
		var game_ctx = game.getContext('2d');
		var game_mousePos = 0;
		// add GameBoard event listener for click events
		
		// create Color Select context and mouse position tracker, and a variable to hold the current color selection
		var select = document.getElementById('selector');
		var select_ctx = select.getContext('2d');
		var select_mousePos = 0;
		var select_color = 'red';
		
		// game logic variables
		var activeRow = 7; // decrements by 1 for each completed line
		var solution = ['red', 'red', 'red', 'red']; // TODO: replace with function to randomly generate solution at startup
		var show_answer = false;
		
		
		// define colors
		var color_boxes_shades = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo'];

		// create the color selection boxes for the Color Select canvas
		var color_rect_coords = makeColorRectCoords();
		makeColorRectBoxes();

		function makeColorRectCoords() {
			var rectarray = [];
			for (var i = 0; i < 6; i++) {
				var newrect = {x:10 + 60*i, y:10, height:50, width:50, boxcolor:color_boxes_shades[i]};
				rectarray[i] = newrect;
			}
			return rectarray;
		}
		
		function makeColorRectBoxes() {
			for (var i = 0; i < 6; i++) {
				var newPath = new Path2D();
				newPath.rect(
					color_rect_coords[i].x,
					color_rect_coords[i].y,
					color_rect_coords[i].height,
					color_rect_coords[i].width);

				color_rect_coords[i].rectangle = newPath;
			}
		}	
		
		// create the game pegs for the GameBoard canvas
		var gamepegs = makeGamePegs();
		makePegBoxes();
		
		function makeGamePegs() {
			var pegs = [];
				for (var c=0; c<8; c++) {
					pegs[c] = ['x'];
					for (var r=0; r<4; r++) {
						pegs[c][r] = {x:10 + 60*r, 
							y:220 + 60*c,
							height:50,
							width:50,
							color:'white'};
					}
				}				
			return pegs;
		}
		
		function makePegBoxes() {
			for (var c = 0; c < 8; c++) {
				for (var r = 0; r < 4; r++) {
					var boxPath = new Path2D();
					boxPath.rect(
						gamepegs[c][r].x, 
						gamepegs[c][r].y, 
						gamepegs[c][r].width, 
						gamepegs[c][r].height);
					gamepegs[c][r].rectangle = boxPath;
				};
			};
		}

		// --- USER INPUT FUNCTIONS ---

		// add EventListener to Select canvas and define its function (to get the color of the square clicked in
		
		select.addEventListener("click", function(evt) {
			
			select_mousePos = getSelectMousePos(select, evt);
			select_color = getSelectorColorAtMouseClick(select_mousePos)
			document.getElementById("output").innerHTML = select_color;
		});
		
		function getSelectorColorAtMouseClick(inputxy) {
			var newcolor = 'none';
			for (var i = 0; i < 6; i++) {
				var boxtocheck = color_rect_coords[i];
				if (inputxy.x > boxtocheck.x && inputxy.y > boxtocheck.y) {
					newcolor = boxtocheck.boxcolor;			
				}
			}
			return newcolor;
		}
		
		function getSelectMousePos(gameboard, evt) {
			var rect = gameboard.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			}
		}
		
		// add EventListener to GameBoard canvas and define its functions (place color at square clicked if and only if the row is valid
		
		game.addEventListener("click", function(evt) {
			game_mousePos = getGameMousePos(game, evt);
			for (var r = 0; r < 4; r++) {
				var activebox = gamepegs[activeRow][r];
				if (game_mousePos.x > activebox.x && game_mousePos.y > activebox.y && game_mousePos.x < activebox.x + 50 && game_mousePos.y < activebox.y + 50) {
					activebox.color = select_color;
				}
			}
		});
		function getGameMousePos(game, evt) {
			var rect = game.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			}
		}

		// page button functions
		function newGame() {
			gamepegs = makeGamePegs();
			makePegBoxes();
			activeRow = 7;
			show_answer = false;
			document.getElementById('output').innerHTML = "new game";
		}
		
		function resetRow() {
			for (var r = 0; r < 4; r++) {
				var activebox = gamepegs[activeRow][r];
				activebox.color = 'white';			
			}
		}
		
		function testRow() {
			for (var r = 0; r < 4; r++) {
				// test for whether there are any white cells in the active row
				if (gamepegs[activeRow][r].color == 'white') {
					alert("Rows cannot have white squares.");
					return;
				}
			}
			var row_to_test = [
				gamepegs[activeRow][0].color,
				gamepegs[activeRow][1].color,
				gamepegs[activeRow][2].color,
				gamepegs[activeRow][3].color];
			var is_match = testRowEqualsAnswer(row_to_test, solution);
			if (is_match == false) {
				if (activeRow == 0) {
					show_answer = true;
				} else {
					activeRow--;				
				}
			
			} else if (is_match == true) {
				show_answer = true;
			}
			document.getElementById('output').innerHTML = is_match;
		}
		
		function testRowEqualsAnswer(testing_row, correct) {
			for (var i = 0; i < 4; i++) {
				if (testing_row[i] !== correct[i]) {
					return false;
				}
			}
			return true;
		}

		// --- DRAWING FUNCTIONS ---
		function drawColorSelector() {
			for (var i = 0; i < 6; i++) {	
				select_ctx.fillStyle = color_rect_coords[i].boxcolor;
				select_ctx.fill(color_rect_coords[i].rectangle);
			};
		}
		
		function drawGamePegs() {
			for (var c = 0; c < 8; c++) {
				for (var r = 0; r < 4; r++) {
					game_ctx.fillStyle = gamepegs[c][r].color;
					game_ctx.fill(gamepegs[c][r].rectangle);
				}
			}
		}
		
		function drawActiveColor() {
			game_ctx.beginPath();
			game_ctx.rect(340, 640, 50, 50);
			game_ctx.fillStyle = select_color;
			game_ctx.fill();
			game_ctx.closePath();
		}
		
		function drawAnswer() {
			for (var i = 0; i < 4; i++) {
				game_ctx.beginPath();
				game_ctx.rect(10 + 60*i, 10, 50, 50);
				game_ctx.fillStyle = solution[i];
				game_ctx.fill();
				game_ctx.closePath();
			}
		}
		
		function drawActiveBox() {
			game_ctx.beginPath();
			game_ctx.strokeRect(5, game.height-485+(60*activeRow), 240, 60);
		}
		
		function drawAnswerFrame() {
			game_ctx.beginPath();
			game_ctx.fillStyle = 'white';
			game_ctx.fillRect(0, 0, 250, 70);
		}
		
		// --- MAIN DRAWING FUNCTION ---
		function drawGameBoard() {
			
			game_ctx.clearRect(0,0, game.width, game.height);
			drawGamePegs();
			drawActiveColor();
			drawAnswerFrame();
			drawActiveBox();
			if (show_answer == true) {
				drawAnswer();
			}
			game_ctx.fillStyle = 'black'
			game_ctx.font = "12px Arial";
			game_ctx.fillText("Active Color", 331, 637);
		}
	
		drawColorSelector();
		setInterval(drawGameBoard, 10);
		// -----------------------------

    </script>
  </body>
</html>
